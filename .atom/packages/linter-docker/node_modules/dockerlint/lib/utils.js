// Generated by CoffeeScript 1.12.4
(function() {
  var base, base1, sty,
    slice = [].slice;

  sty = require('sty');

  if ((base = String.prototype).beginsWith == null) {
    base.beginsWith = function(s) {
      return this.slice(0, s.length) === s;
    };
  }

  if ((base1 = String.prototype).endsWith == null) {
    base1.endsWith = function(s) {
      return s === '' || this.slice(-s.length) === s;
    };
  }

  exports.notEmpty = function(s) {
    return !(s.trim() === '');
  };

  exports.log = function(level, msg) {
    switch (level) {
      case 'FATAL':
      case 5:
        console.error((sty.red('ERROR')) + ": " + msg);
        return process.exit(1);
      case 'ERROR':
      case 4:
        return console.error((sty.red('ERROR')) + ": " + msg);
      case 'WARN':
      case 3:
        return console.warn((sty.yellow('WARN')) + ":  " + msg);
      case 'INFO':
      case 2:
        return console.log((sty.green('INFO')) + ": " + msg);
      default:
        process.stdout.write((sty.blue('DEBUG')) + ":");
        return console.dir(msg);
    }
  };

  exports.isArray = function(a) {
    return (!!a) && (a.constructor === Array);
  };

  exports.merge = function() {
    var xs;
    xs = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if ((xs != null ? xs.length : void 0) > 0) {
      return exports.tap({}, function(m) {
        var i, k, len, results, v, x;
        results = [];
        for (i = 0, len = xs.length; i < len; i++) {
          x = xs[i];
          results.push((function() {
            var results1;
            results1 = [];
            for (k in x) {
              v = x[k];
              results1.push(m[k] = v);
            }
            return results1;
          })());
        }
        return results;
      });
    }
  };

  exports.tap = function(o, fn) {
    fn(o);
    return o;
  };

}).call(this);
